name: CI/CD Pipeline

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]
  workflow_dispatch:

env:
  ECR_REPOSITORY_NAME: todo-app-03-ecr
  AWS_REGION: eu-central-1

jobs:
  # JOB 1: Build da imagem e envio para o ECR
  build:
    name: Build e Push para ECR
    runs-on: ubuntu-latest
    outputs:
      image_uri: ${{ steps.build-image.outputs.image_uri }}
      image_tag: ${{ github.sha }}
    
    steps:
    - name: Checkout cÃ³digo
      uses: actions/checkout@v3
      
    - name: Configurar AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        mask-aws-account-id: 'no'
        
    - name: Verificar Credenciais
      run: |
        aws sts get-caller-identity
    
    - name: Configurar Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.0.0
        
    - name: Terraform Init
      run: |
        cd application
        terraform init
        
    # Modificar o arquivo main.tf para usar create_before_destroy
    - name: Configurar Terraform para lidar com recursos existentes
      run: |
        echo "Ajustando a configuraÃ§Ã£o do mÃ³dulo ECR..."
        cat > modules/ecr/main.tf <<EOF
resource "aws_ecr_repository" "app_repository" {
  name                 = var.repository_name
  image_tag_mutability = var.image_tag_mutability
  
  # Isto permite que o Terraform atualize corretamente recursos existentes
  lifecycle {
    # Impede que o Terraform tente destruir e recriar o recurso
    prevent_destroy = true
    # Ignora alteraÃ§Ãµes especÃ­ficas que podem causar recriaÃ§Ãµes desnecessÃ¡rias
    ignore_changes = [
      image_scanning_configuration,
      encryption_configuration
    ]
  }
  
  image_scanning_configuration {
    scan_on_push = var.scan_on_push
  }

  encryption_configuration {
    encryption_type = var.encryption_type
  }

  tags = var.tags
}

# PolÃ­tica de lifecycle para manter apenas um nÃºmero especÃ­fico de imagens
resource "aws_ecr_lifecycle_policy" "app_lifecycle_policy" {
  repository = aws_ecr_repository.app_repository.name

  policy = jsonencode({
    rules = [
      {
        rulePriority = 1
        description  = "Keep last \${var.image_count_to_keep} images"
        selection = {
          tagStatus     = "any"
          countType     = "imageCountMoreThan"
          countNumber   = var.image_count_to_keep
        }
        action = {
          type = "expire"
        }
      }
    ]
  })
}
EOF
        
    # Aplicar apenas o mÃ³dulo ECR com a opÃ§Ã£o refresh-only 
    - name: Verificar e Sincronizar Estado do ECR
      run: |
        cd application
        echo "Sincronizando o estado do Terraform com o ECR existente..."
        terraform apply -refresh-only -auto-approve
        
    # Aplicar apenas o mÃ³dulo ECR para garantir que existe
    - name: Criar/Atualizar RepositÃ³rio ECR
      run: |
        cd application
        echo "Aplicando apenas a configuraÃ§Ã£o do ECR..."
        # Usando o flag -target para aplicar apenas o mÃ³dulo ECR e suprimindo erros de saÃ­da
        terraform apply -auto-approve -target=module.ecr_repository || true
        
        # Verificar e exportar detalhes do ECR
        ECR_REPOSITORY_URL=$(terraform output -raw ecr_repository_url || echo "")
        if [ -z "$ECR_REPOSITORY_URL" ]; then
          echo "Buscando informaÃ§Ãµes do repositÃ³rio ECR via AWS CLI..."
          ECR_REPOSITORY_URL=$(aws ecr describe-repositories --repository-names $ECR_REPOSITORY_NAME --query 'repositories[0].repositoryUri' --output text || echo "")
        fi
        
        echo "RepositÃ³rio ECR URL: $ECR_REPOSITORY_URL"
        echo "ECR_REPOSITORY_URL=$ECR_REPOSITORY_URL" >> $GITHUB_ENV
    
    # Login no ECR
    - name: Login no Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1
      
    # Build e Push
    - name: Build e Push da Imagem
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ${{ env.ECR_REPOSITORY_NAME }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "Verificando informaÃ§Ãµes do ECR:"
        echo "Registry: $ECR_REGISTRY"
        echo "Repository: $ECR_REPOSITORY"
        echo "Tag: $IMAGE_TAG"
        
        # Navegar para o diretÃ³rio que contÃ©m o Dockerfile
        cd app
        
        # Corrigir o Dockerfile se necessÃ¡rio
        if grep -q "CMD \[\"npm\", \"start\"\]" Dockerfile; then
          sed -i 's/CMD \["npm", "start"\]/CMD \["npm", "run", "dev"\]/' Dockerfile
          echo "Corrigido o comando no Dockerfile"
        fi
        
        # Build da imagem Docker
        echo "Construindo imagem: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
        
        # Push da imagem para o ECR
        echo "Enviando imagem para o ECR..."
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        # Salvar a URI da imagem para o prÃ³ximo job
        IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
        echo "image_uri=$IMAGE_URI" >> $GITHUB_OUTPUT
        echo "Imagem construÃ­da e enviada com sucesso: $IMAGE_URI"

  # JOB 2: Deploy da aplicaÃ§Ã£o no cluster EKS
  deploy:
    name: Deploy no EKS
    runs-on: ubuntu-latest
    needs: build  # Depende do job de build
    if: github.ref == 'refs/heads/master' && github.event_name != 'pull_request'
    
    steps:
    - name: Checkout cÃ³digo
      uses: actions/checkout@v3
      
    - name: Configurar AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Configurar Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.0.0
        
    - name: Terraform Init
      run: |
        cd application
        terraform init
    
    # Modificar o arquivo main.tf para usar prevent_destroy tambÃ©m no job de deploy
    - name: Configurar Terraform para lidar com recursos existentes
      run: |
        echo "Ajustando a configuraÃ§Ã£o do mÃ³dulo ECR..."
        cat > modules/ecr/main.tf <<EOF
resource "aws_ecr_repository" "app_repository" {
  name                 = var.repository_name
  image_tag_mutability = var.image_tag_mutability
  
  # Isto permite que o Terraform atualize corretamente recursos existentes
  lifecycle {
    # Impede que o Terraform tente destruir e recriar o recurso
    prevent_destroy = true
    # Ignora alteraÃ§Ãµes especÃ­ficas que podem causar recriaÃ§Ãµes desnecessÃ¡rias
    ignore_changes = [
      image_scanning_configuration,
      encryption_configuration
    ]
  }
  
  image_scanning_configuration {
    scan_on_push = var.scan_on_push
  }

  encryption_configuration {
    encryption_type = var.encryption_type
  }

  tags = var.tags
}

# PolÃ­tica de lifecycle para manter apenas um nÃºmero especÃ­fico de imagens
resource "aws_ecr_lifecycle_policy" "app_lifecycle_policy" {
  repository = aws_ecr_repository.app_repository.name

  policy = jsonencode({
    rules = [
      {
        rulePriority = 1
        description  = "Keep last \${var.image_count_to_keep} images"
        selection = {
          tagStatus     = "any"
          countType     = "imageCountMoreThan"
          countNumber   = var.image_count_to_keep
        }
        action = {
          type = "expire"
        }
      }
    ]
  })
}
EOF
    
    # Aplicar configuraÃ§Ã£o completa do Terraform
    - name: Deploy da AplicaÃ§Ã£o
      run: |
        cd application
        echo "Aplicando configuraÃ§Ã£o Terraform com a nova imagem..."
        terraform apply -auto-approve \
          -var="app_image_tag=${{ needs.build.outputs.image_tag }}" \
          -var="use_ecr_image=true" \
          -var="ecr_repository_name=$ECR_REPOSITORY_NAME"
        echo "Terraform aplicado com sucesso!"
        
    # Verificar o deployment
    - name: Verificar Deployment
      run: |
        echo "Instalando kubectl..."
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/
        
        echo "Configurando kubectl para o cluster EKS..."
        aws eks update-kubeconfig --name eksDeepDiveFrankfurt --region $AWS_REGION
        
        echo "Verificando o status do deployment..."
        kubectl get deployment todo-app-03
        kubectl get pods -l app=todo-app-03
      
    # Exibir a URL da aplicaÃ§Ã£o
    - name: Exibir URL da AplicaÃ§Ã£o
      run: |
        cd application
        LOAD_BALANCER_URL=$(terraform output -raw app_url || echo "URL nÃ£o disponÃ­vel")
        echo "============================================="
        echo "ðŸš€ A aplicaÃ§Ã£o foi implantada com sucesso!"
        echo "ðŸ“± Acesse a aplicaÃ§Ã£o em: $LOAD_BALANCER_URL"
        echo "============================================="
